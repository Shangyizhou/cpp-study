## 内存管理

### 无存储器抽象

最简单的存储器抽象就是无抽象，每一个程序都直接访问物理内存。

```c++
MOV REGISTER1, 1000
```

计算机会将位置为`1000`的物理内存中的内容移动到`REGISTER1`中。在这样的情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在物理内存`2000`的位置写入一个新的值，将会擦掉第二个程序在相同位置上的内容，这样两个程序会崩溃掉。

**在不使用存储器抽象的情况下运行多个程序**

操作系统只需把当前内存中所有内容保存到磁盘文件中，然后将下一个程序读入到内存中再运行即可。只要在某一个时间内内存中只有一个程序，那么就不会发生冲突。**这是一种交换的概念**

在特殊硬件帮助下，即使没有交换功能也可以并发运行多个程序。`IBM360`早期模型，将内存划分为`2KB`的块，每个块被分配一个`4`位的保护键。程序状态字中存有一个`4`位码。一个运行中的进程如果访问保护键与其程序状态字不同的内存，那么这个事件就会被硬件捕获。这样可以防止用户进程之间、用户进程和操作系统之间的干扰。

![image-20220228214429811](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220228214429811.png)

但是，这样的程序仍然是访问绝对物理地址，那么就可能会出现相同的物理地址被不同进程访问的现象，程序依旧会崩溃（之前是写入读入一些内存可能会重复在同一物理地址上，现在是虽然分割开来了，但是如果有一个`jump`指令跳到了别人的地盘，那么也是错误访问，程序崩溃）

**我们希望每个程序都有一套私有的本地地址来进行内存寻址**

### 一种存储器抽象：地址空间

将物理地址暴露给进程会带来严重的问题

- 用户可以寻址内存的每个字节，很容易的破坏操作系统
- 使用这种模型想要同时运行多个程序是困难的

**地址空间**

要使多个应用程序处于内存中且不相互映像，需要解决两个问题：保护和重定位

我们可以创建一个新的存储器抽象：地址空间。地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。这样就不会访问同一处绝对物理地址了。

地址空间的概念：相当于电话号码`0 000 000 - 9 999 999`，每个数都是一个`地址`。或者`IPV4`的地址，`0~2的32次方`

难点在于如何将每个进程的`地址28`映射到不同的物理地址上

**基址寄存器与界限寄存器**

我们可以使用 **动态重定位** 解决上述问题

- 我们直接将每个进程的地址空间映射到物理内存的不同部分，每个`CPU`配置两个特殊硬件寄存器，**基址寄存器和界限寄存器**。
- 程序装载到内存中连续的空闲位置且装载期间无需重定位。
- 当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中

每次一个进程访问内存，取一条指令，读或写一个数据字，`CPU`硬件都会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器的值。如果访问地址超出界限，会产生错误并中止访问。

![image-20220228215350871](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220228215350871.png)



比如对上述指令`JMP 28`，硬件会解释成`JMP 16412`

**使用基址寄存器的缺点**

每次访问内存都需要进行加法和比较运算，会很慢

会有内存碎片

**交换技术**

之前的基址寄存器和界限寄存器避免了进程间访问同一物理内存的错误，通过重定位使进程都在各自的内存空间内运行。但是，我们的内存真的有这么大可以容纳所有的进程吗？显然，这点内存是不够的

有两种处理内存超载的通用方法

- 交换技术：把一个进程完整调入内存，使该进程运行一段事件，然后把它存辉磁盘。空闲进程主要储存在磁盘上，所以不运行时就不会占用内存。
- 虚拟内存技术：该策略使程序在只有一部分被调入内存的情况下运行

![image-20220228220037646](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220228220037646.png)

刚开始内存中只有`进程A`，之后创建`进程B和C`或者从磁盘将它们换入内存

可以看见，交换在内存中产生了许多空闲区（内存碎片），通过把所有进程尽可能向下移动，使得空闲区合成一大块，这种技术叫做内存紧缩。（这会耗费`CPU`大量事件）

还需注意一件事情，一个进程如果分配时确定了大小那么会容易不少，但是若进程会涉及到一些动态分配内存的情况，就需要为进程预留空间。这些空间不一定会用到，会有些浪费。

**这里设计将堆向上增长，让栈向下增长，所以只需留一处预留空间即可，设计更为方便**

![image-20220228220303694](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220228220303694.png)

**空间内存管理**

有两种方法跟踪内存使用情况

- 位图
- 空闲区链表

**使用位图的存储管理**

内存被分为小到几个字或大到几千字节的分配单元，每个分配单元对应位图中的一位。`0`表示空闲，`1`表示占用。假设设计分配单元为`4`个字节，那么就有`32位`，而`32位`的分配单元只需要位图的`1位`。因为内存的大小和分配单元的大小决定了位图的大小，所以它提供了一种简单的利用一块固定大小的内存区就能对内存使用情况进行记录的方法。

问题：把一个占`k`个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出有`k`个连续`0`的串。这是耗时的操作

**使用空闲链表的存储管理**

维护一个记录已分配内存字段和空闲内存段的链表，其中链表中的一个结点或者包含一个进程，或者是两个进程间的一块空闲区。

> 存储管理器是如何分配空闲内存的？

**首次适配算法**

存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小正好和要求的一样，否则将空闲区分为两块，一块供给进程使用，另一块形成新的空闲区。这个算法简单，快速，可以尽可能少的搜索结点。

**下次适配算法**

与首次适配算法差不多，但是每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索。而不是像适配算法一样从链表头开始搜索。

**最佳适配算法**

搜索整个链表，找出能够容纳进程的最小的空闲区。该算法找到的空闲区最接近实际需要的空闲区，而不是找到一个足够大的再分成两部分。

### 虚拟内存

尽管基址寄存器和界限寄存器可以用于创建地址空间的抽象，但是随着软件的大小不断增加和需要并发的软件逐渐增多，我们的内存完全不够同时容纳这么多进程。并且之前提出的交换技术并不能很好的解决这个问题。

虚拟内存：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块被称作一页或页面。每一页有连续的地址范围，这些页被映射到物理内存，但并不是所有页都必须在内存中才能运行程序。

**虚拟内存使得整个地址空间可以用较小的单元映射到物理内存，而不是为正文段和数据段分别进行重定位**

**分页**

有程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在有虚拟内存的情况下，虚拟地址不是被送到内存总线上，而是被送到内存管理单元`MMU`，`MMU`把虚拟地址映射为物理内存地址。

![image-20220228230200622](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220228230200622.png)

在这个例子中，有一台可以产生`16位地址`的计算机，地址范围从`64-1`, 且这些地址是虚拟地址。然而，这台计算机只有`32K`的物理内存，因此，虽然可以编写`64KB`程序，但它们却不能被完全调人内存运行。在磁盘上必须有个最多`64KB`程序核心映像的完整副本，以保证程序片段在需要时能被调入内存。

- 虚拟地址按照固定大小划分成称为页面的若干个单元，物理内存也同样，其对应的单元叫做页框。一般都为`4KB`
- 上图，标记`0K~4K`范围表示该页的虚拟地址或物理地址是`0~4095`

程序试图访问地址0时，`MOV REG, 0`，将虚拟地址`0`送到`MMU`，`MMU`看到虚拟地址`0`落在页面`0(0~4095)`。根据其映射结果，这一页面对应的 是页框 (`8192~12287`), 因此MMU把地址变换为8192, 井把地址8192送到总线上。内存对MMU一无所知，它只看到一个读或写地址8192的请求并执行它。 MMU从而有效地把所有从`0~4095`的虚拟地址映 射到了`8192~12287`的物理地址。

**通过恰当的设置MMU，可以把16个虚拟页面映射到8个页框中的任何一个**

但是，虚拟地址空间这样就比物理地址大了，如果访问了一个虚拟地址，其未被映射到物理地址，`MMU`会发现该页面没有被映射，于是使`CPU`陷入到操作系统，这个陷阱叫做 **缺页中断** 。操作系统找到一个很少使用的页框且把它的内容写入磁盘，然后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令；













